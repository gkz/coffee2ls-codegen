// Generated by CoffeeScript 1.3.3
(function() {
  var codegen,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (function(exports) {
    var TAB, clone, eq, formatInterpolation, formatStringData, genVar, generate, generateArgs, indent, levels, lsReserved, needsParensWhenOnLeft, operators, parens, precedence;
    TAB = '  ';
    indent = function(code) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = code.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push("" + TAB + line);
        }
        return _results;
      })()).join('\n');
    };
    parens = function(code) {
      return "(" + code + ")";
    };
    formatStringData = function(data) {
      return data.replace(/[^\x20-\x7e]|['\\]/g, function(c) {
        var escape, pad;
        switch (c) {
          case '\0':
            return '\\0';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\n':
            return '\\n';
          case '\f':
            return '\\f';
          case '\r':
            return '\\r';
          case '\'':
            return '\\\'';
          case '\\':
            return '\\\\';
          default:
            escape = (c.charCodeAt(0)).toString(16);
            pad = "0000".slice(escape.length);
            return "\\u" + pad + escape;
        }
      });
    };
    formatInterpolation = function(ast, options) {
      var left, right;
      switch (ast.className) {
        case "ConcatOp":
          left = formatInterpolation(ast.left, options);
          right = formatInterpolation(ast.right, options);
          return "" + left + right;
        case "String":
          return formatStringData(ast.data);
        default:
          return "\#{" + (generate(ast, options)) + "}";
      }
    };
    needsParensWhenOnLeft = function(ast) {
      switch (ast.className) {
        case 'Function':
        case 'BoundFunction':
        case 'NewOp':
        case 'Class':
          return true;
        case 'Conditional':
        case 'Switch':
        case 'While':
        case 'ForIn':
        case 'ForOf':
        case 'Block':
          return true;
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'LogicalNotOp':
        case 'BitNotOp':
        case 'DoOp':
        case 'TypeofOp':
        case 'DeleteOp':
          return needsParensWhenOnLeft(ast.expression);
        case 'FunctionApplication':
          return ast["arguments"].length > 0;
        case 'Super':
        case 'Try':
          return true;
        default:
          return false;
      }
    };
    eq = function(nodeA, nodeB) {
      var i, prop, v, val, _i, _len;
      for (prop in nodeA) {
        if (!__hasProp.call(nodeA, prop)) continue;
        val = nodeA[prop];
        if (prop === 'raw' || prop === 'line' || prop === 'column') {
          continue;
        }
        switch (Object.prototype.toString.call(val)) {
          case '[object Object]':
            if (!eq(nodeB[prop], val)) {
              return false;
            }
            break;
          case '[object Array]':
            for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
              v = val[i];
              if (!eq(nodeB[prop][i], v)) {
                return false;
              }
            }
            break;
          default:
            if (nodeB[prop] !== val) {
              return false;
            }
        }
      }
      return true;
    };
    clone = function(obj, overrides) {
      var newObj, prop, val;
      if (overrides == null) {
        overrides = {};
      }
      newObj = {};
      for (prop in obj) {
        if (!__hasProp.call(obj, prop)) continue;
        val = obj[prop];
        newObj[prop] = val;
      }
      for (prop in overrides) {
        if (!__hasProp.call(overrides, prop)) continue;
        val = overrides[prop];
        newObj[prop] = val;
      }
      return newObj;
    };
    generateArgs = function(args, options) {
      var a, arg, argList, i;
      if (options == null) {
        options = {};
      }
      if (args.length) {
        argList = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
            a = args[i];
            arg = generate(a, options);
            if (((needsParensWhenOnLeft(a)) && i + 1 !== args.length) || (a.className === 'Function' && i === 0)) {
              arg = parens(arg);
            }
            _results.push(arg);
          }
          return _results;
        })();
        return argList.join(', ');
      } else {
        return '';
      }
    };
    genVar = function(options, name) {
      var i, out, _ref;
      if (name == null) {
        name = 'ref';
      }
      i = 0;
      while (_ref = (out = "" + name + (i || '') + "$$"), __indexOf.call(options.varsTotal, _ref) >= 0) {
        ++i;
      }
      options.varsTotal.push(out);
      options.varsFunc.push(out);
      return out;
    };
    levels = [['SeqOp'], ['Conditional', 'ForIn', 'ForOf', 'While'], ['FunctionApplication', 'SoakedFunctionApplication'], ['AssignOp', 'CompoundAssignOp', 'ExistsAssignOp'], ['LogicalOrOp'], ['LogicalAndOp'], ['BitOrOp'], ['BitXorOp'], ['BitAndOp'], ['ExistsOp'], ['EQOp', 'NEQOp'], ['LTOp', 'LTEOp', 'GTOp', 'GTEOp', 'InOp', 'OfOp', 'InstanceofOp'], ['LeftShiftOp', 'SignedRightShiftOp', 'UnsignedRightShiftOp'], ['PlusOp', 'SubtractOp'], ['MultiplyOp', 'DivideOp', 'RemOp'], ['ExpOp', 'ExtendOp'], ['UnaryPlusOp', 'UnaryNegateOp', 'LogicalNotOp', 'BitNotOp', 'DoOp', 'TypeofOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'], ['UnaryExistsOp', 'ShallowCopyArray', 'PostIncrementOp', 'PostDecrementOp', 'Spread'], ['NewOp'], ['MemberAccessOp', 'SoakedMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicProtoMemberAccessOp', 'SoakedProtoMemberAccessOp', 'SoakedDynamicProtoMemberAccessOp']];
    precedence = {};
    (function() {
      var level, op, ops, _i, _len, _results;
      _results = [];
      for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
        ops = levels[level];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
            op = ops[_j];
            _results1.push(precedence[op] = level);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    operators = {
      SeqOp: ';',
      LogicalOrOp: '||',
      LogicalAndOp: '&&',
      BitOrOp: '.|.',
      BitXorOp: '.^.',
      BitAndOp: '.&.',
      EQOp: 'is',
      NEQOp: 'isnt',
      LTOp: '<',
      LTEOp: '<=',
      GTOp: '>',
      GTEOp: '>=',
      InOp: 'in',
      OfOp: 'of',
      InstanceofOp: 'instanceof',
      ExtendsOp: 'extends',
      LeftShiftOp: '.<<.',
      SignedRightShiftOp: '.>>.',
      UnsignedRightShiftOp: '.>>>.',
      PlusOp: '+',
      SubtractOp: '-',
      MultiplyOp: '*',
      DivideOp: '/',
      RemOp: '%',
      ExpOp: '**',
      AssignOp: '=',
      ExistsAssignOp: '?:=',
      ExistsOp: '?',
      UnaryPlusOp: '+',
      UnaryNegateOp: '-',
      LogicalNotOp: 'not ',
      BitNotOp: '~',
      NewOp: 'new ',
      TypeofOp: 'typeof ',
      PreIncrementOp: '++',
      PreDecrementOp: '--',
      Spread: '...',
      UnaryExistsOp: '?',
      ShallowCopyArray: '[..]',
      PostIncrementOp: '++',
      PostDecrementOp: '--',
      FunctionApplication: '',
      SoakedFunctionApplication: '?',
      MemberAccessOp: '.',
      SoakedMemberAccessOp: '?.',
      ProtoMemberAccessOp: '::',
      SoakedProtoMemberAccessOp: '?::',
      DynamicMemberAccessOp: '',
      SoakedDynamicMemberAccessOp: '?',
      DynamicProtoMemberAccessOp: '::',
      SoakedDynamicProtoMemberAccessOp: '?::'
    };
    lsReserved = ['it', 'that', 'fallthrough', 'otherwise', 'where', 'xor', 'match'];
    return exports.generate = generate = function(ast, options) {
      var absNum, allNew, allReassign, c, comprehension, exp, expression_, finallyBody, findIds, firstRef, flag, hasAlternate, i, isMultiline, key_, left, line, m, matched, memberAccessOps, members_, needsParens, newline, nonLiteral, out, output, p, parameters, parent, parentClassName, prec, reg, right, s, secondRef, sep, spaces, src, state, type, usedAsExpression, v, vars, _alternate, _argList, _args, _assg, _assignee, _block, _body, _by, _catchAssg, _catchBody, _condition, _conditions, _consequent, _ctor, _expr, _expression, _exprs, _filter, _finally, _firstAssg, _flags, _fn, _fn_indented, _indexingExpr, _left, _main, _mainPart, _mid, _nameAssg, _op, _output, _own, _paramList, _parent, _rangeLeft, _rangeRight, _ref, _ref1, _ref2, _ref3, _right, _s, _secondAssg, _step, _symbol, _target;
      if (options == null) {
        options = {};
      }
      if (!(ast != null)) {
        return '';
      }
      needsParens = false;
      if ((_ref = options.precedence) == null) {
        options.precedence = 0;
      }
      if ((_ref1 = options.ancestors) == null) {
        options.ancestors = [];
      }
      if ((_ref2 = options.varsTotal) == null) {
        options.varsTotal = [];
      }
      if ((_ref3 = options.varsFunc) == null) {
        options.varsFunc = [];
      }
      parent = options.ancestors[0];
      parentClassName = parent != null ? parent.className : void 0;
      usedAsExpression = (parent != null) && parentClassName !== 'Block';
      src = (function() {
        var _i, _j, _len, _len1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (ast.className) {
          case 'Program':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            if (ast.body != null) {
              return generate(ast.body, options);
            } else {
              return '';
            }
            break;
          case 'Block':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: 0
            });
            if (ast.statements.length === 0) {
              return generate((new Undefined).g(), options);
            } else {
              sep = parentClassName === 'Program' ? '\n\n' : '\n';
              return ((function() {
                var _i, _len, _ref4, _results;
                _ref4 = ast.statements;
                _results = [];
                for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                  s = _ref4[_i];
                  _results.push(generate(s, options));
                }
                return _results;
              })()).join(sep);
            }
            break;
          case 'Conditional':
            options.ancestors.unshift(ast);
            options.precedence = 0;
            hasAlternate = (ast.consequent != null) && (ast.alternate != null);
            _consequent = generate((_ref4 = ast.consequent) != null ? _ref4 : (new Undefined).g(), options);
            _alternate = hasAlternate ? generate(ast.alternate, options) : "";
            _condition = generate(ast.condition, options);
            isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
            if (hasAlternate) {
              _alternate = isMultiline ? "\nelse\n" + (indent(_alternate)) : " else " + _alternate;
            }
            if (!isMultiline && !hasAlternate && !usedAsExpression) {
              return "" + _consequent + " if " + _condition;
            } else if (isMultiline) {
              return "if " + _condition + "\n" + (indent(_consequent)) + _alternate;
            } else {
              return "if " + _condition + " then " + _consequent + _alternate;
            }
            break;
          case 'Identifier':
            if (_ref5 = ast.data, __indexOf.call(lsReserved, _ref5) >= 0) {
              return genVar(options, ast.data);
            } else {
              return ast.data;
            }
            break;
          case 'Null':
            return 'null';
          case 'This':
            return 'this';
          case 'Undefined':
            return 'void';
          case 'Int':
            absNum = ast.data < 0 ? -ast.data : ast.data;
            if (absNum >= 1e12 || (absNum > 0x90 && 0 === (absNum & (absNum - 1)))) {
              return "0x" + (ast.data.toString(16));
            } else {
              return ast.data.toString(10);
            }
            break;
          case 'Float':
            return ast.data.toString(10);
          case 'String':
            return "'" + (formatStringData(ast.data)) + "'";
          case 'Bool':
            return "" + (ast.data.toString());
          case 'ArrayInitialiser':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            members_ = (function() {
              var _i, _len, _ref6, _results;
              _ref6 = ast.members;
              _results = [];
              for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
                m = _ref6[_i];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return "[" + (members_.join(', ')) + "]";
              default:
                return "[\n" + (indent(members_.join('\n'))) + "\n]";
            }
            break;
          case 'ObjectInitialiser':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            members_ = (function() {
              var _j, _len1, _ref6, _results;
              _ref6 = ast.members;
              _results = [];
              for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
                m = _ref6[_j];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return "{" + (members_.join(', ')) + "}";
              default:
                return "{\n" + (indent(members_.join('\n'))) + "\n}";
            }
            break;
          case 'ObjectInitialiserMember':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            key_ = generate(ast.key, options);
            expression_ = generate(ast.expression, options);
            memberAccessOps = ['MemberAccessOp', 'ProtoMemberAccessOp', 'SoakedMemberAccessOp', 'SoakedProtoMemberAccessOp'];
            if (eq(ast.key, ast.expression)) {
              return "" + key_;
            } else if ((_ref6 = ast.expression.className, __indexOf.call(memberAccessOps, _ref6) >= 0) && ast.key.data === ast.expression.memberName) {
              return "" + expression_;
            } else {
              return "" + key_ + ": " + expression_;
            }
            break;
          case 'Function':
          case 'BoundFunction':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression,
              varsTotal: options.varsTotal.slice(0),
              varsFunc: []
            });
            parameters = (function() {
              var _j, _len1, _ref7, _results;
              _ref7 = ast.parameters;
              _results = [];
              for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
                p = _ref7[_j];
                _results.push(generate(p, options));
              }
              return _results;
            })();
            options.precedence = 0;
            _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
            _paramList = ast.parameters.length > 0 ? "(" + (parameters.join(', ')) + ") " : '';
            _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? " " + _body : "\n" + (indent(_body));
            switch (ast.className) {
              case 'Function':
                return "" + _paramList + "->" + _block;
              case 'BoundFunction':
                return "" + _paramList + "~>" + _block;
            }
            break;
          case 'AssignOp':
          case 'ExistsAssignOp':
            _op = operators[ast.className];
            if (ast.className === 'AssignOp') {
              vars = [];
              findIds = function(node) {
                var member, _j, _len1, _ref7;
                switch (node.className) {
                  case 'Identifier':
                    vars.push(node.data);
                    break;
                  case 'Rest':
                    vars.push(node.expression.data);
                    break;
                  case 'ObjectInitialiserMember':
                    vars.push(node.expression.data);
                    break;
                  case 'ArrayInitialiser':
                  case 'ObjectInitialiser':
                    _ref7 = node.members;
                    for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
                      member = _ref7[_j];
                      findIds(member);
                    }
                }
                return void 0;
              };
              findIds(ast.assignee);
              if (vars.length) {
                allNew = true;
                allReassign = true;
                for (_j = 0, _len1 = vars.length; _j < _len1; _j++) {
                  v = vars[_j];
                  if (__indexOf.call(options.varsTotal, v) >= 0 && __indexOf.call(options.varsFunc, v) < 0) {
                    allNew = false;
                  } else {
                    allReassign = false;
                    options.varsTotal.push(v);
                    options.varsFunc.push(v);
                  }
                }
                if (allReassign) {
                  _op = ':=';
                } else if (!allNew) {
                  throw new Error('mixed reassign and initialisation in destructuring is not currently supported');
                }
              }
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " " + _op + " " + _expr;
          case 'CompoundAssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _op = operators[ast.op];
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            _assg = (_ref7 = ast.op) === 'LogicalOrOp' || _ref7 === 'LogicalAndOp' ? ':=' : '=';
            return "" + _assignee + " " + _op + _assg + " " + _expr;
          case 'SeqOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            _right = generate(ast.right, options);
            return "" + _left + "; " + _right;
          case 'LogicalOrOp':
          case 'LogicalAndOp':
          case 'BitOrOp':
          case 'BitXorOp':
          case 'BitAndOp':
          case 'LeftShiftOp':
          case 'SignedRightShiftOp':
          case 'UnsignedRightShiftOp':
          case 'EQOp':
          case 'NEQOp':
          case 'LTOp':
          case 'LTEOp':
          case 'GTOp':
          case 'GTEOp':
          case 'InOp':
          case 'OfOp':
          case 'InstanceofOp':
          case 'PlusOp':
          case 'SubtractOp':
          case 'MultiplyOp':
          case 'DivideOp':
          case 'RemOp':
          case 'ExistsOp':
          case 'ExpOp':
          case 'ExtendsOp':
            _op = operators[ast.className];
            if (((_ref8 = ast.className) === 'InOp' || _ref8 === 'OfOp' || _ref8 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
              _op = "not " + _op;
            }
            if (!options.inFunctionApplication) {
              if (ast.className === 'LogicalOrOp') {
                _op = 'or';
              } else if (ast.className === 'LogicalAndOp') {
                _op = 'and';
              }
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            if (needsParensWhenOnLeft(ast.left)) {
              _left = parens(_left);
            }
            _right = generate(ast.right, options);
            return "" + _left + " " + _op + " " + _right;
          case 'ChainedComparisonOp':
            return generate(ast.expression, options);
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'TypeofOp':
          case 'PreIncrementOp':
          case 'PreDecrementOp':
          case 'Spread':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            if (ast.className === 'LogicalNotOp') {
              if ((_ref9 = ast.expression.className) === 'InOp' || _ref9 === 'OfOp' || _ref9 === 'InstanceofOp') {
                _op = '';
                prec = precedence[ast.expression.className];
              }
              if (('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) || 'EQOp' === parentClassName) {
                _op = '!';
              }
            }
            needsParens = prec < options.precedence;
            if (parentClassName === ast.className && ((_ref10 = ast.className) === 'UnaryPlusOp' || _ref10 === 'UnaryNegateOp')) {
              needsParens = true;
            }
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.className === 'UnaryNegateOp' && ast.expression.className === 'PreDecrementOp') {
              return "-" + (parens(generate(ast.expression, options)));
            } else {
              return "" + _op + (generate(ast.expression, options));
            }
            break;
          case 'DeleteOp':
            return "delete! " + (generate(ast.expression, options));
          case 'UnaryExistsOp':
          case 'PostIncrementOp':
          case 'PostDecrementOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _expr = generate(ast.expression, options);
            if (needsParensWhenOnLeft(ast.expression)) {
              _expr = parens(_expr);
            }
            return "" + _expr + _op;
          case 'NewOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _ctor = generate(ast.ctor, options);
            if (ast["arguments"].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
              _ctor = parens(_ctor);
            }
            options.precedence = precedence['AssignOp'];
            _args = ast["arguments"].length ? " " + (generateArgs(ast["arguments"], options)) : '';
            return "" + _op + _ctor + _args;
          case 'FunctionApplication':
          case 'SoakedFunctionApplication':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence[ast.className],
              inFunctionApplication: true
            });
            _op = operators[ast.className];
            _fn = generate(ast["function"], options);
            if (needsParensWhenOnLeft(ast["function"])) {
              _fn = parens(_fn);
            }
            if (ast.className === 'FunctionApplication' && ast["arguments"].length === 0 && (parentClassName !== 'UnaryExistsOp' && parentClassName !== 'SoakedMemberAccessOp')) {
              return "" + _fn + "!";
            } else {
              _argList = ast["arguments"].length ? " " + (generateArgs(ast["arguments"], options)) : '()';
              if (_fn_indented = _fn.match(/\n(\s+).*$/)) {
                matched = _fn_indented[0], spaces = _fn_indented[1];
                _argList = ((function() {
                  var _k, _len2, _ref11, _results;
                  _ref11 = _argList.split('\n');
                  _results = [];
                  for (_k = 0, _len2 = _ref11.length; _k < _len2; _k++) {
                    line = _ref11[_k];
                    _results.push(line.replace(new RegExp("^" + spaces), "" + TAB + spaces));
                  }
                  return _results;
                })()).join('\n');
              }
              return "" + _fn + _op + _argList;
            }
            break;
          case 'MemberAccessOp':
          case 'SoakedMemberAccessOp':
          case 'ProtoMemberAccessOp':
          case 'SoakedProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            newline = false;
            if (ast.expression.className === 'This') {
              _expr = '@';
              if (ast.className === 'MemberAccessOp') {
                _op = '';
              }
            } else {
              _expr = generate(ast.expression, options);
              reg = new RegExp("\\n\\s*\\." + ast.memberName + "$");
              if (ast.raw && ast.raw.match(reg)) {
                newline = true;
              } else {
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
            }
            if (newline) {
              return ("" + _expr + "\n") + indent("" + _op + ast.memberName);
            } else {
              return "" + _expr + _op + ast.memberName;
            }
            break;
          case 'DynamicMemberAccessOp':
          case 'SoakedDynamicMemberAccessOp':
          case 'DynamicProtoMemberAccessOp':
          case 'SoakedDynamicProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            options.precedence = 0;
            _indexingExpr = generate(ast.indexingExpr, options);
            if (ast.className === 'DynamicMemberAccessOp' && ((_ref11 = ast.indexingExpr.className) === 'String' || _ref11 === 'Int')) {
              return "" + _expr + _op + "." + _indexingExpr;
            } else {
              return "" + _expr + _op + "[" + _indexingExpr + "]";
            }
            break;
          case 'ConcatOp':
            _left = formatInterpolation(ast.left, options);
            _right = formatInterpolation(ast.right, options);
            return "\"" + _left + _right + "\"";
          case 'Rest':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _expr = generate(ast.expression, options);
            return "..." + _expr;
          case 'RegExp':
          case 'HeregExp':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _symbol = '//';
            _exprs = ast.className === 'RegExp' ? ast.data : formatInterpolation(ast.expression, options);
            _flags = '';
            _ref12 = ast.flags;
            for (flag in _ref12) {
              state = _ref12[flag];
              if (state) {
                _flags += flag;
              }
            }
            return "" + _symbol + _exprs + _symbol + _flags;
          case 'DoOp':
            exp = ast.expression;
            if (exp.className === 'Function' && (((exp.body != null) && exp.body.className !== 'Undefined') || exp.parameters.length)) {
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec,
                varsTotal: options.varsTotal.slice(0),
                varsFunc: []
              });
              _op = 'let ';
              parameters = (function() {
                var _k, _len2, _ref13, _results;
                _ref13 = exp.parameters;
                _results = [];
                for (_k = 0, _len2 = _ref13.length; _k < _len2; _k++) {
                  p = _ref13[_k];
                  _results.push(generate(p, options));
                }
                return _results;
              })();
              options.precedence = 0;
              if ((exp.body != null) && exp.body.className !== 'Undefined') {
                _body = generate(exp.body, options);
              } else {
                _body = 'void';
              }
              _paramList = parameters.length > 0 ? "" + (parameters.join(', ')) : '';
              return "" + _op + _paramList + "\n" + (indent(_body));
            } else {
              _op = 'do ';
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              return "" + _op + (generate(ast.expression, options));
            }
            break;
          case 'DefaultParam':
            return "" + (generate(ast.param, options)) + " = " + (generate(ast["default"], options));
          case 'JavaScript':
            return "``" + ast.data + "``";
          case 'Range':
          case 'Slice':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _by = '';
            if (ast.left && ast.right && ast.className === 'Range') {
              left = +(generate(ast.left, options));
              right = +(generate(ast.right, options));
              if (left === left && right === right) {
                if (left === right && !ast.isInclusive) {
                  _main = '[]';
                }
              } else {
                nonLiteral = true;
              }
            } else {
              '';

            }
            _mid = ast.isInclusive ? 'to' : 'til';
            _left = ast.left ? generate(ast.left, options) : '';
            _right = ast.right ? generate(ast.right, options) : '';
            _target = ast.expression ? generate(ast.expression, options) : '';
            if (ast.className === 'Slice') {
              if (_left == null) {
                _left = '0';
              }
              if (ast.left && ast.left.className === 'String') {
                _left = "+" + _left;
              }
              if (ast.right && ast.right.className === 'String') {
                _right = "+" + _right;
              }
              if (_right && _mid === 'to') {
                _right = "" + _right + " + 1 || 9e9";
              }
              _args = [_left, _right].join(', ');
              return "" + _target + ".slice(" + _args + ")";
            } else {
              if (_main) {
                return _main;
              } else if (nonLiteral && !_by) {
                firstRef = genVar(options);
                secondRef = genVar(options);
                return parens("if (" + firstRef + " = " + _left + ") > (" + secondRef + " = " + _right + ") then [" + firstRef + " " + _mid + " " + secondRef + " by -1] else [" + firstRef + " " + _mid + " " + secondRef + "]");
              } else {
                return "[" + _left + " " + _mid + " " + _right + _by + "]";
              }
            }
            break;
          case 'ForIn':
          case 'ForOf':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            type = ast.className === 'ForIn' ? 'in' : 'of';
            _own = ast.isOwn ? 'own ' : '';
            _firstAssg = ast.valAssignee ? generate(ast.valAssignee, options) : '';
            _secondAssg = ast.keyAssignee ? generate(ast.keyAssignee, options) : '';
            if (type === 'of') {
              _ref13 = [_secondAssg, _firstAssg], _firstAssg = _ref13[0], _secondAssg = _ref13[1];
            }
            if (_secondAssg) {
              _secondAssg = ", " + _secondAssg;
            }
            _target = type === 'in' && ast.target.className === 'Range' ? (_mid = ast.target.isInclusive ? 'to' : 'til', ast.target.left.className === 'Int' && ast.target.left.data === 0 ? _rangeLeft = '' : _rangeLeft = "from " + (generate(ast.target.left, options)) + " ", _rangeRight = generate(ast.target.right, options), "" + _rangeLeft + _mid + " " + _rangeRight) : "" + type + " " + (generate(ast.target, options));
            _step = !ast.step || ast.step.className === 'Int' && ast.step.data === 1 ? '' : " by " + (generate(ast.step, options));
            _filter = ast.filter ? " when " + (generate(ast.filter, options)) : '';
            comprehension = false;
            _body = ast.body ? (comprehension = ast.body.className === 'Block' ? 1 === ast.body.statements.length && 'For' !== ast.body.statements[0].className.slice(0, 3) : ((_ref14 = ast.body.className) !== 'Function' && _ref14 !== 'BoundFunction') && 'For' !== ast.body.className.slice(0, 3), comprehension && (comprehension = usedAsExpression), generate(ast.body, options)) : 'void';
            _mainPart = "for " + _own + _firstAssg + _secondAssg + " " + _target + _step + _filter;
            if (comprehension) {
              return "[" + _body + " " + _mainPart + "]";
            } else {
              _output = "" + _mainPart + "\n" + (indent(_body));
              if (usedAsExpression && parentClassName !== 'AssignOp') {
                return parens(_output);
              } else {
                return _output;
              }
            }
            break;
          case 'While':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _condition = generate(ast.condition, options);
            _body = ast.body ? generate(ast.body, options) : 'void';
            return "while " + _condition + "\n" + (indent(_body));
          case 'Switch':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _expression = ast.expression ? " " + (generate(ast.expression, options)) : '';
            output = "switch" + _expression + "\n";
            output += ((function() {
              var _k, _len2, _ref15, _results;
              _ref15 = ast.cases;
              _results = [];
              for (_k = 0, _len2 = _ref15.length; _k < _len2; _k++) {
                c = _ref15[_k];
                _results.push(generate(c, options));
              }
              return _results;
            })()).join('\n');
            if (ast.alternate) {
              output += "\ndefault\n" + (indent(generate(ast.alternate, options)));
            }
            return output;
          case 'SwitchCase':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _conditions = ast.conditions.length ? ((function() {
              var _k, _len2, _ref15, _results;
              _ref15 = ast.conditions;
              _results = [];
              for (_k = 0, _len2 = _ref15.length; _k < _len2; _k++) {
                c = _ref15[_k];
                _results.push(generate(c, options));
              }
              return _results;
            })()).join(', ') : generate(ast.conditions, options);
            return "case " + _conditions + "\n" + (indent(generate(ast.consequent, options)));
          case 'Return':
            return "return " + (generate(ast.expression, options));
          case 'Break':
            return 'break';
          case 'Continue':
            return 'continue';
          case 'Throw':
            return "throw " + (generate(ast.expression, options));
          case 'Try':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _body = ast.body ? generate(ast.body, options) : 'void';
            _catchAssg = ast.catchAssignee ? " " + (generate(ast.catchAssignee)) : '';
            _catchBody = ast.catchBody ? "\n" + (indent(generate(ast.catchBody, options))) : '';
            finallyBody = ast.finallyBody ? generate(ast.finallyBody, options) : '';
            _finally = finallyBody ? "\nfinally\n" + (indent(finallyBody)) : '';
            out = "try\n" + (indent(_body)) + "\ncatch" + _catchAssg + _catchBody + _finally;
            if (usedAsExpression) {
              return parens(out);
            } else {
              return out;
            }
            break;
          case 'Super':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _args = ast["arguments"].length ? "" + (generateArgs(ast["arguments"], options)) : '...';
            return "super " + _args;
          case 'Class':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _s = '';
            _nameAssg = ast.nameAssignee ? (_s = ' ', generate(ast.nameAssignee, options)) : '';
            _parent = ast.parent ? " extends " + (generate(ast.parent, options)) : '';
            _body = ast.body ? "\n" + (indent(generate(ast.body, options))) : '';
            if (((_ref15 = ast.nameAssignee) != null ? _ref15.className : void 0) === 'MemberAccessOp') {
              return "" + _nameAssg + " = class" + _parent + _body;
            } else {
              return "class" + _s + _nameAssg + _parent + _body;
            }
            break;
          case 'Constructor':
            _body = generate(ast.expression, options);
            if (ast.expression.className === 'Function') {
              return _body;
            } else {
              return "constructor$$: " + _body;
            }
            break;
          case 'ClassProtoAssignOp':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            _assignee = generate(ast.assignee, options);
            _expression = generate(ast.expression, options);
            return "" + _assignee + ": " + _expression;
          default:
            throw new Error("Non-exhaustive patterns in case: " + ast.className);
        }
      })();
      if (needsParens) {
        return parens(src);
      } else {
        return src;
      }
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this.coffee2ls - (codegen = {}));

}).call(this);
